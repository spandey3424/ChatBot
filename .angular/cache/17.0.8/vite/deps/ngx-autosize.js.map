{
  "version": 3,
  "sources": ["../../../../../node_modules/ngx-autosize/fesm2020/ngx-autosize.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nclass WindowRef {\n  get nativeWindow() {\n    return window;\n  }\n}\nWindowRef.ɵfac = function WindowRef_Factory(t) {\n  return new (t || WindowRef)();\n};\nWindowRef.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: WindowRef,\n  factory: WindowRef.ɵfac\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(WindowRef, [{\n    type: Injectable\n  }], null, null);\n})();\nconst MAX_LOOKUP_RETRIES = 3;\nclass AutosizeDirective {\n  constructor(element, _window, _zone) {\n    this.element = element;\n    this._window = _window;\n    this._zone = _zone;\n    this.onlyGrow = false;\n    this.useImportant = false;\n    this.resized = new EventEmitter();\n    this.autosize = true;\n    this.retries = 0;\n    this._destroyed = false;\n    if (this.element.nativeElement.tagName !== 'TEXTAREA') {\n      this._findNestedTextArea();\n    } else {\n      this.textAreaEl = this.element.nativeElement;\n      this.textAreaEl.style['overflow-y'] = 'hidden';\n      this._onTextAreaFound();\n    }\n  }\n  set minRows(value) {\n    this._minRows = +value;\n    if (this.textAreaEl) {\n      this.textAreaEl.rows = this._minRows;\n    }\n  }\n  set _autosize(autosize) {\n    this.autosize = typeof autosize === 'boolean' ? autosize : true;\n  }\n  onInput(textArea) {\n    this.adjust();\n  }\n  ngOnDestroy() {\n    this._destroyed = true;\n    if (this._windowResizeHandler) {\n      this._window.nativeWindow.removeEventListener('resize', this._windowResizeHandler, false);\n    }\n  }\n  ngAfterContentChecked() {\n    this.adjust();\n  }\n  ngOnChanges(changes) {\n    this.adjust(true);\n  }\n  _findNestedTextArea() {\n    this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');\n    if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {\n      this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');\n    }\n    if (!this.textAreaEl) {\n      if (this.retries >= MAX_LOOKUP_RETRIES) {\n        console.warn('ngx-autosize: textarea not found');\n      } else {\n        this.retries++;\n        setTimeout(() => {\n          this._findNestedTextArea();\n        }, 100);\n      }\n      return;\n    }\n    this.textAreaEl.style['overflow-y'] = 'hidden';\n    this._onTextAreaFound();\n  }\n  _onTextAreaFound() {\n    this._addWindowResizeHandler();\n    setTimeout(() => {\n      this.adjust();\n    });\n  }\n  _addWindowResizeHandler() {\n    this._windowResizeHandler = debounce(() => {\n      this._zone.run(() => {\n        this.adjust();\n      });\n    }, 200);\n    this._zone.runOutsideAngular(() => {\n      this._window.nativeWindow.addEventListener('resize', this._windowResizeHandler, false);\n    });\n  }\n  adjust(inputsChanged = false) {\n    if (this.autosize && !this._destroyed && this.textAreaEl && this.textAreaEl.parentNode) {\n      const currentText = this.textAreaEl.value;\n      if (inputsChanged === false && currentText === this._oldContent && this.textAreaEl.offsetWidth === this._oldWidth) {\n        return;\n      }\n      this._oldContent = currentText;\n      this._oldWidth = this.textAreaEl.offsetWidth;\n      const clone = this.textAreaEl.cloneNode(true);\n      const parent = this.textAreaEl.parentNode;\n      clone.style.width = this.textAreaEl.offsetWidth + 'px';\n      clone.style.visibility = 'hidden';\n      clone.style.position = 'absolute';\n      clone.textContent = currentText;\n      parent.appendChild(clone);\n      clone.style['overflow-y'] = 'hidden';\n      clone.style.height = 'auto';\n      let height = clone.scrollHeight;\n      // add into height top and bottom borders' width\n      let computedStyle = this._window.nativeWindow.getComputedStyle(clone, null);\n      height += parseInt(computedStyle.getPropertyValue('border-top-width'));\n      height += parseInt(computedStyle.getPropertyValue('border-bottom-width'));\n      if (computedStyle.getPropertyValue('box-sizing') === 'content-box') {\n        height -= parseInt(computedStyle.getPropertyValue('padding-top'));\n        height -= parseInt(computedStyle.getPropertyValue('padding-bottom'));\n      }\n      const oldHeight = this.textAreaEl.offsetHeight;\n      const willGrow = height > oldHeight;\n      if (this.onlyGrow === false || willGrow) {\n        const lineHeight = this._getLineHeight();\n        const rowsCount = height / lineHeight;\n        if (this._minRows && this._minRows >= rowsCount) {\n          height = this._minRows * lineHeight;\n        } else if (this.maxRows && this.maxRows <= rowsCount) {\n          // never shrink the textarea if onlyGrow is true\n          const maxHeight = this.maxRows * lineHeight;\n          height = this.onlyGrow ? Math.max(maxHeight, oldHeight) : maxHeight;\n          this.textAreaEl.style['overflow-y'] = 'auto';\n        } else {\n          this.textAreaEl.style['overflow-y'] = 'hidden';\n        }\n        const heightStyle = height + 'px';\n        const important = this.useImportant ? 'important' : '';\n        this.textAreaEl.style.setProperty('height', heightStyle, important);\n        this.resized.emit(height);\n      }\n      parent.removeChild(clone);\n    }\n  }\n  _getLineHeight() {\n    let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);\n    if (isNaN(lineHeight) && this._window.nativeWindow.getComputedStyle) {\n      const styles = this._window.nativeWindow.getComputedStyle(this.textAreaEl);\n      lineHeight = parseInt(styles.lineHeight, 10);\n    }\n    if (isNaN(lineHeight)) {\n      const fontSize = this._window.nativeWindow.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');\n      lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);\n    }\n    return lineHeight;\n  }\n}\nAutosizeDirective.ɵfac = function AutosizeDirective_Factory(t) {\n  return new (t || AutosizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(WindowRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nAutosizeDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: AutosizeDirective,\n  selectors: [[\"\", \"autosize\", \"\"]],\n  hostBindings: function AutosizeDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"input\", function AutosizeDirective_input_HostBindingHandler($event) {\n        return ctx.onInput($event.target);\n      });\n    }\n  },\n  inputs: {\n    minRows: \"minRows\",\n    _autosize: [\"autosize\", \"_autosize\"],\n    maxRows: \"maxRows\",\n    onlyGrow: \"onlyGrow\",\n    useImportant: \"useImportant\"\n  },\n  outputs: {\n    resized: \"resized\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutosizeDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[autosize]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: WindowRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    minRows: [{\n      type: Input\n    }],\n    _autosize: [{\n      type: Input,\n      args: ['autosize']\n    }],\n    maxRows: [{\n      type: Input\n    }],\n    onlyGrow: [{\n      type: Input\n    }],\n    useImportant: [{\n      type: Input\n    }],\n    resized: [{\n      type: Output\n    }],\n    onInput: [{\n      type: HostListener,\n      args: ['input', ['$event.target']]\n    }]\n  });\n})();\nfunction debounce(func, timeout) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      func(...args);\n    }, timeout);\n  };\n}\nclass AutosizeModule {}\nAutosizeModule.ɵfac = function AutosizeModule_Factory(t) {\n  return new (t || AutosizeModule)();\n};\nAutosizeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AutosizeModule,\n  declarations: [AutosizeDirective],\n  exports: [AutosizeDirective]\n});\nAutosizeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [WindowRef],\n  imports: [[]]\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutosizeModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [AutosizeDirective],\n      imports: [],\n      providers: [WindowRef],\n      exports: [AutosizeDirective]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-autosize\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutosizeDirective, AutosizeModule, WindowRef };\n"],
  "mappings": "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",
  "names": []
}
